dnl Process this m4 file to produce 'C' language file.
dnl
dnl If you see this line, you can ignore the next one.
/* Do not edit this file. It is produced from the corresponding .m4 source */
dnl
/*********************************************************************
 *
 *  Copyright (C) 2017, Northwestern University and Argonne National Laboratory
 *  See COPYRIGHT notice in top-level directory.
 *
 *********************************************************************/
/* $Id: transpose.c 3078 2017-05-29 22:46:50Z wkliao $ */

#include <stdio.h>
#include <stdlib.h>
#include <string.h> /* strcpy(), strncpy() */
#include <strings.h> /* strcasecmp() */
#include <libgen.h> /* basename() */
#include <mpi.h>
#include <pnetcdf.h>

#include <testutils.h>

#define NDIMS 3
#define LEN   2

include(`foreach.m4')dnl
include(`utils.m4')dnl

#define text char
#ifndef schar
#define schar signed char
#endif
#ifndef uchar
#define uchar unsigned char
#endif
#ifndef ushort
#define ushort unsigned short
#endif
#ifndef uint
#define uint unsigned int
#endif
#ifndef longlong
#define longlong long long
#endif
#ifndef ulonglong
#define ulonglong unsigned long long
#endif

define(`TEST_BLOCKING_PUT',dnl
`dnl
static int
blocking_put_$1(int         rank,
                int         coll_io,
                int         ncid,
                int        *dimids,
                MPI_Offset *start,
                MPI_Offset *count,
                MPI_Offset *startS,
                MPI_Offset *countS,
                MPI_Offset *stride,
                MPI_Offset *startM,
                MPI_Offset *countM,
                MPI_Offset *imap,
                ifelse(`$1',`text',`char',`double') *buf)
{
    int err, nerrs=0;
    int var1_id, vara_id, vars_id, varm_id;
    int dimid, dimidsT[NDIMS];
    MPI_Offset start1[1];

    /* file sync before re-entering define mode */
    err = ncmpi_sync(ncid);
    CHECK_ERR
    MPI_Barrier(MPI_COMM_WORLD);

    /* re-enter define mode, so we can add more variables */
    err = ncmpi_redef(ncid); CHECK_ERR
    err = ncmpi_inq_dimid(ncid, "nprocs", &dimid); CHECK_ERR
    err = ncmpi_def_var(ncid, "var1_$1", NC_TYPE($1),     1, &dimid, &var1_id); CHECK_ERR
    err = ncmpi_def_var(ncid, "vara_$1", NC_TYPE($1), NDIMS, dimids, &vara_id); CHECK_ERR
    err = ncmpi_def_var(ncid, "vars_$1", NC_TYPE($1), NDIMS, dimids, &vars_id); CHECK_ERR

    /* define variable with transposed file layout: ZYX -> YXZ */
    dimidsT[0] = dimids[1]; dimidsT[1] = dimids[2]; dimidsT[2] = dimids[0];
    err = ncmpi_def_var(ncid, "varm_$1", NC_TYPE($1), NDIMS, dimidsT, &varm_id); CHECK_ERR

    /* exit the define mode */
    err = ncmpi_enddef(ncid); CHECK_ERR

    if (!coll_io) {
        err = ncmpi_begin_indep_data(ncid);
        CHECK_ERR
    }

    /* write the whole variable in parallel */
    start1[0] = rank;
    if (coll_io)
        err = `ncmpi_put_var1_'ifelse(`$1',`text',`$1',`double')`_all'(ncid, var1_id, start1, buf);
    else
        err = `ncmpi_put_var1_'ifelse(`$1',`text',`$1',`double')(ncid, var1_id, start1, buf);
    CHECK_ERR

    if (coll_io)
        err = `ncmpi_put_vara_'ifelse(`$1',`text',`$1',`double')`_all'(ncid, vara_id, start, count, buf);
    else
        err = `ncmpi_put_vara_'ifelse(`$1',`text',`$1',`double')(ncid, vara_id, start, count, buf);
    CHECK_ERR

    if (coll_io)
        err = `ncmpi_put_vars_'ifelse(`$1',`text',`$1',`double')`_all'(ncid, vars_id, startS, countS, stride, buf);
    else
        err = `ncmpi_put_vars_'ifelse(`$1',`text',`$1',`double')(ncid, vars_id, startS, countS, stride, buf);
    CHECK_ERR

    if (coll_io)
        err = `ncmpi_put_varm_'ifelse(`$1',`text',`$1',`double')`_all'(ncid, varm_id, startM, countM, NULL, imap, buf);
    else
        err = `ncmpi_put_varm_'ifelse(`$1',`text',`$1',`double')(ncid, varm_id, startM, countM, NULL, imap, buf);
    CHECK_ERR

    return nerrs;
}
')dnl

foreach(`itype',(`text,schar,uchar,short,ushort,int,uint,long,float,double,longlong,ulonglong'),`TEST_BLOCKING_PUT(itype)')

define(`TEST_CDF_FORMAT',dnl
`dnl
    /* create a new file */
    err = ncmpi_create(MPI_COMM_WORLD, out_path, NC_CLOBBER, info, &ncid);
    if (err != NC_NOERR) {
        printf("Error at line %d in %s: ncmpi_create() file %s (%s)\n",
        __LINE__,__FILE__,fname,ncmpi_strerror(err));
        CHECK_ERR
    }

    /* define dimensions */
    err = ncmpi_def_dim(ncid, "nprocs", nprocs,   &dimids[0]); CHECK_ERR
    err = ncmpi_def_dim(ncid, "Z",      gsize[0], &dimids[0]); CHECK_ERR
    err = ncmpi_def_dim(ncid, "Y",      gsize[1], &dimids[1]); CHECK_ERR
    err = ncmpi_def_dim(ncid, "X",      gsize[2], &dimids[2]); CHECK_ERR
    err = ncmpi_enddef(ncid);

    if (!coll_io) {
        err = ncmpi_begin_indep_data(ncid);
        CHECK_ERR
    }

    nerrs += blocking_put_text(rank, coll_io, ncid, dimids, start, count,
             startS, countS, stride, startM, countM, imap, cbuf);
    foreach(`itype',(`schar,short,int,long,float,double'),`
    _CAT(`nerrs += blocking_put_',itype)'`(rank, coll_io, ncid, dimids, start,
        count, startS, countS, stride, startM, countM, imap, buf);')

    if (format == NC_FORMAT_64BIT_DATA) {
        foreach(`itype',
        (`uchar,ushort,uint,longlong,ulonglong'),`
        _CAT(`nerrs += blocking_put_',itype)'`(rank, coll_io, ncid, dimids,
            start, count, startS, countS, stride, startM, countM, imap, buf);')
    }

    /* close the file */
    err = ncmpi_close(ncid);
    CHECK_ERR
')dnl

static
int test_io(const char *out_path,
            const char *in_path, /* ignored */
            int         format,
            int         coll_io,
            MPI_Info    info)
{
    char fname[512], *cbuf;
    int i, j, k, rank, nprocs, ncid, bufsize, err, nerrs=0;
    int psize[NDIMS], dimids[NDIMS], dim_rank[NDIMS];
    double *buf;
    MPI_Offset gsize[NDIMS], stride[NDIMS], imap[NDIMS];
    MPI_Offset start[NDIMS], count[NDIMS];
    MPI_Offset startS[NDIMS], countS[NDIMS];
    MPI_Offset startM[NDIMS], countM[NDIMS];

    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &nprocs);

    /* calculate number of processes along each dimension */
    for (i=0; i<NDIMS; i++) psize[i] = 0;
    MPI_Dims_create(nprocs, NDIMS, psize);

    /* for each MPI rank, find its local rank IDs along each dimension in
     * dim_rank[] */
    int lower_dims=1;
    for (i=NDIMS-1; i>=0; i--) {
        dim_rank[i] = rank / lower_dims % psize[i];
        lower_dims *= psize[i];
    }

    /* calculate gsize[], global array sizes and set arguments start and count
     * for vara APIs */
    bufsize = 1;
    for (i=0; i<NDIMS; i++) {
        gsize[i]  = (MPI_Offset)LEN * psize[i];    /* global array size */
        start[i]  = (MPI_Offset)LEN * dim_rank[i]; /* start indices */
        count[i]  = (MPI_Offset)LEN;               /* array elements */
        bufsize  *= LEN;
    }

    /* allocate buffer and initialize with contiguous numbers */
    buf = (double *) malloc(sizeof(double) * bufsize);
    for (k=0; k<count[0]; k++)
    for (j=0; j<count[1]; j++)
    for (i=0; i<count[2]; i++)
        buf[k*count[1]*count[2] +
                     j*count[2] + i] = (start[0]+k)*gsize[1]*gsize[2]
                                     + (start[1]+j)*gsize[2]
                                     + (start[2]+i); // + 1000*(rank+1);
    cbuf = (char *) malloc(bufsize);
    for (i=0; i<bufsize; i++) cbuf[i] = '0'+rank;

    /* set an MPI-IO hint to disable file offset alignment for fixed-size
     * variables */
    MPI_Info_set(info, "nc_var_align_size", "1");

    /* set arguments start, count, stride for vars APIs */
    for (i=0; i<NDIMS; i++) {
        startS[i] = dim_rank[i];
        countS[i] = gsize[i] / psize[i];
        stride[i] = psize[i];
    }

    /* ZYX -> YXZ: (this is borrowed from examples/C/transpose.c */
    imap[1] = 1; imap[0] = count[2]; imap[2] = count[1]*count[2];
    startM[0] = start[1]; startM[1] = start[2]; startM[2] = start[0];
    countM[0] = count[1]; countM[1] = count[2]; countM[2] = count[0];

    /* Set format. */
    err = ncmpi_set_default_format(format, NULL);
    CHECK_ERR

    TEST_CDF_FORMAT

    free(cbuf);
    free(buf);

    return nerrs;
}

int main(int argc, char **argv) {

    int err;
    loop_opts opt;

    MPI_Init(&argc, &argv);

    opt.num_fmts = sizeof(nc_formats) / sizeof(int);
    opt.formats  = nc_formats;
    opt.ina      = 1; /* test intra-node aggregation */
    opt.drv      = 1; /* test PNCIO driver */
    opt.ind      = 1; /* test hint romio_no_indep_rw */
    opt.chk      = 1; /* test hint nc_data_move_chunk_size */
    opt.bb       = 1; /* test burst-buffering feature */
    opt.mod      = 1; /* test independent data mode */
    opt.hdr_diff = 1; /* run ncmpidiff for file header only */
    opt.var_diff = 1; /* run ncmpidiff for variables */

    err = tst_main(argc, argv, "all kinds put APIs", opt, test_io);

    MPI_Finalize();

    return err;
}

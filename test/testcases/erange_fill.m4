dnl Process this m4 file to produce 'C' language file.
dnl
dnl If you see this line, you can ignore the next one.
/* Do not edit this file. It is produced from the corresponding .m4 source */
dnl
/*
 *  Copyright (C) 2016, Northwestern University and Argonne National Laboratory
 *  See COPYRIGHT notice in top-level directory.
 *
 *  $Id$
 */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 * This program is only active when macro ERANGE_FILL is defined.
 * It tests whether the data elemensts is "filled" with "filled values" when
 * their contents (to be read or written) cause NC_ERANGE error.
 *
 * The compile and run commands are given below.
 *
 *    % mpicc -g -o erange_fill.c erange_fill -lpnetcdf
 *
 *    % mpiexec -l -n 1 erange_fill erange_fill.nc
 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <libgen.h> /* basename() */
#include <pnetcdf.h>

#include <testutils.h>

/* Set LEN to a value of multiple of 4. Otherwise, for single-byte types, such
 * as NC_BYTE, "holes" can appear between two consecutive fixed-size variables.
 * The classic NetCDF formats require zero padding for those "holes", but
 * PnetCDF does not implement that requirement.
 */
#define LEN 12

static int bb_enabled;

include(`foreach.m4')dnl
include(`utils.m4')dnl

#define text char

#ifndef schar
#define schar signed char
#endif
#ifndef uchar
#define uchar unsigned char
#endif
#ifndef ushort
#define ushort unsigned short
#endif
#ifndef uint
#define uint unsigned int
#endif
#ifndef longlong
#define longlong long long
#endif
#ifndef ulonglong
#define ulonglong unsigned long long
#endif

define(`ITYPE_SIZE',`ifelse(
`$1', `text',      `1',dnl
`$1', `schar',     `1',dnl
`$1', `uchar',     `1',dnl
`$1', `short',     `2',dnl
`$1', `ushort',    `2',dnl
`$1', `int',       `4',dnl
`$1', `long',      `4',dnl
`$1', `uint',      `4',dnl
`$1', `float',     `4',dnl
`$1', `double',    `8',dnl
`$1', `longlong',  `8',dnl
`$1', `ulonglong', `8')')dnl

define(`CHECK_DEFAULT_FILL_VALUE',`
    err = ncmpi_inq_varid(ncid, "var_$1", &varid); CHECK_ERR
    if (coll_io)
        err = GET_VAR($1,_all)(ncid, varid, buf_$1);
    else
        err = GET_VAR($1)(ncid, varid, buf_$1);
    CHECK_ERR
    for (i=0; i<LEN; i++) {
        if (buf_$1[i] != NC_FILL_VALUE($1)) {
            printf("Error at %s line %d: expect buf_$1[%d]=IFMT($1) but got IFMT($1)\n",
                   __func__,__LINE__,i,($1)NC_FILL_VALUE($1),buf_$1[i]);
            nerrs++;
        }
    }
')dnl

static
int test_default_fill_mode(const char *out_path, int format, int coll_io, MPI_Info info) {
    int i, err, nerrs=0, ncid, old_mode, dimid, varid;
    MPI_Comm comm=MPI_COMM_WORLD;
    foreach(`itype', (ITYPE_LIST), `
    itype _CAT(`buf_',itype)'`[LEN];')

    /* create a new file */
    err = ncmpi_create(comm, out_path, NC_CLOBBER, info, &ncid); CHECK_ERR
    err = ncmpi_set_fill(ncid, NC_FILL, &old_mode); CHECK_ERR
    if (old_mode == NC_FILL) {
        printf("Error at %s line %d: expected NC_NOFILL but got NC_FILL\n",__func__,__LINE__);
        nerrs++;
    }

    err = ncmpi_def_dim(ncid, "X", LEN, &dimid); CHECK_ERR

    foreach(`itype', (CDF2_ITYPE_LIST), `
    _CAT(`err = ncmpi_def_var(ncid, "var_',itype)'`", NC_TYPE(itype), 1, &dimid, &varid); CHECK_ERR')

    if (format == NC_FORMAT_CDF5) {
        foreach(`itype', (CDF5_EXTRA_ITYPE_LIST), `
        _CAT(`err = ncmpi_def_var(ncid, "var_',itype)'`", NC_TYPE(itype), 1, &dimid, &varid); CHECK_ERR')
    }

    err = ncmpi_enddef(ncid); CHECK_ERR

    if (!coll_io) {
        err = ncmpi_begin_indep_data(ncid);
        CHECK_ERR
    }

    foreach(`itype', (CDF2_ITYPE_LIST), `CHECK_DEFAULT_FILL_VALUE(itype)')
    if (format == NC_FORMAT_CDF5) {
        foreach(`itype', (CDF5_EXTRA_ITYPE_LIST), `CHECK_DEFAULT_FILL_VALUE(itype)')
    }

    err = ncmpi_close(ncid); CHECK_ERR
    return nerrs;
}

define(`CHECK_USER_FILL_VALUE',`
    err = ncmpi_inq_varid(ncid, "var_$1", &varid); CHECK_ERR
    if (coll_io)
        err = GET_VAR($1,_all)(ncid, varid, buf_$1);
    else
        err = GET_VAR($1)(ncid, varid, buf_$1);
    CHECK_ERR
    for (i=0; i<LEN; i++) {
        if (buf_$1[i] != fillv_$1) {
            printf("Error at %s line %d: expect buf_$1[%d]=IFMT($1) but got IFMT($1)\n",
                   __func__,__LINE__,i,fillv_$1,buf_$1[i]);
            nerrs++;
        }
    }
')dnl

static
int test_user_fill_mode(const char *out_path, int format, int coll_io, MPI_Info info) {
    int i, err, nerrs=0, ncid, dimid, varid;
    MPI_Comm comm=MPI_COMM_WORLD;
    foreach(`itype', (ITYPE_LIST), `
    itype _CAT(`buf_',itype)[LEN], _CAT(`fillv_',itype);')

    /* create a new file */
    err = ncmpi_create(comm, out_path, NC_CLOBBER, info, &ncid); CHECK_ERR

    err = ncmpi_def_dim(ncid, "X", LEN, &dimid); CHECK_ERR

    foreach(`itype', (CDF2_ITYPE_LIST), `
    _CAT(`fillv_',itype)' = 99;`
    err = ncmpi_def_var(ncid, _CAT(`"var_',itype)", NC_TYPE(itype), 1, &dimid, &varid); CHECK_ERR
    err = ncmpi_put_att(ncid, varid, "_FillValue", NC_TYPE(itype), 1, _CAT(`&fillv_',itype)); CHECK_ERR
    /* enable variable fill mode with fill value from attribute just set */
    err = ncmpi_def_var_fill(ncid, varid, 0, NULL); CHECK_ERR
    ')

    if (format == NC_FORMAT_CDF5) {
        foreach(`itype', (CDF5_EXTRA_ITYPE_LIST), `
        _CAT(`fillv_',itype)' = 99;`
        err = ncmpi_def_var(ncid, _CAT(`"var_',itype)", NC_TYPE(itype), 1, &dimid, &varid); CHECK_ERR
        err = ncmpi_put_att(ncid, varid, "_FillValue", NC_TYPE(itype), 1, _CAT(`&fillv_',itype)); CHECK_ERR
        /* enable variable fill mode with fill value from attribute just set */
        err = ncmpi_def_var_fill(ncid, varid, 0, NULL); CHECK_ERR
        ')
    }
    /* put attribute _FillValue does not automatically enable file mode */


    err = ncmpi_enddef(ncid); CHECK_ERR

    if (!coll_io) {
        err = ncmpi_begin_indep_data(ncid);
        CHECK_ERR
    }

    foreach(`itype', (CDF2_ITYPE_LIST), `CHECK_USER_FILL_VALUE(itype)')
    if (format == NC_FORMAT_CDF5) {
        foreach(`itype', (CDF5_EXTRA_ITYPE_LIST), `CHECK_USER_FILL_VALUE(itype)')
    }

    err = ncmpi_close(ncid); CHECK_ERR
    return nerrs;
}

define(`TEST_ERANGE_PUT',dnl
`dnl
static
int test_erange_put_$1_$2(const char *out_path, int coll_io, MPI_Info info) {
    int i, err, nerrs=0, ncid, dimid, varid1, varid2, cdf;
    $1 buf[LEN], fillv=99;
    MPI_Comm comm=MPI_COMM_WORLD;

    /* create a new file */
    err = ncmpi_create(comm, out_path, NC_CLOBBER, info, &ncid); CHECK_ERR

    err = ncmpi_set_fill(ncid, NC_FILL, NULL); CHECK_ERR
    err = ncmpi_def_dim(ncid, "X", LEN, &dimid); CHECK_ERR
    err = ncmpi_def_var(ncid, "var1", NC_TYPE($1), 1, &dimid, &varid1); CHECK_ERR
    err = ncmpi_def_var(ncid, "var2", NC_TYPE($1), 1, &dimid, &varid2); CHECK_ERR
    /* use non-default fill value */
    err = ncmpi_put_att(ncid, varid2, "_FillValue", NC_TYPE($1), 1, &fillv); CHECK_ERR
    err = ncmpi_enddef(ncid); CHECK_ERR

    if (!coll_io) {
        err = ncmpi_begin_indep_data(ncid);
        CHECK_ERR
    }

    err = ncmpi_inq_format(ncid, &cdf); CHECK_ERR

    /* put data with ERANGE values */
    $2 wbuf[LEN];
    for (i=0; i<LEN; i++) wbuf[i] = ($2) ifelse(index(`$1',`u'), 0, `-1', `XTYPE_MAX($2)');
    if (coll_io)
        err = PUT_VAR($2,_all)(ncid, varid1, wbuf);
    else
        err = PUT_VAR($2)(ncid, varid1, wbuf);
    if (bb_enabled) {
        CHECK_ERR
        err = ncmpi_flush(ncid);
    }

    ifelse(`$1',`schar',`ifelse(`$2',`uchar',`if (cdf == NC_FORMAT_CDF2) CHECK_ERR',`EXP_ERR(NC_ERANGE)')',`EXP_ERR(NC_ERANGE)')
    if (coll_io)
        err = PUT_VAR($2,_all)(ncid, varid2, wbuf);
    else
        err = PUT_VAR($2)(ncid, varid2, wbuf);
    if (bb_enabled) {
        CHECK_ERR
        err = ncmpi_flush(ncid);
    }

    ifelse(`$1',`schar',`ifelse(`$2',`uchar',`if (cdf == NC_FORMAT_CDF2) CHECK_ERR',`EXP_ERR(NC_ERANGE)')',`EXP_ERR(NC_ERANGE)')

    /* file sync before reading */
    if (!coll_io) {
        err = ncmpi_sync(ncid);
        CHECK_ERR
    }
    MPI_Barrier(MPI_COMM_WORLD);

    err = ncmpi_inq_varid(ncid, "var1", &varid1); CHECK_ERR
    if (coll_io)
        err = GET_VAR($1,_all)(ncid, varid1, buf);
    else
        err = GET_VAR($1)(ncid, varid1, buf);
    CHECK_ERR
    for (i=0; i<LEN; i++) {
        $1 expect = ($1)NC_FILL_VALUE($1);
        ifelse(`$1',`schar',`ifelse(`$2',`uchar',`if (cdf != NC_FORMAT_CDF5) expect = ($1)wbuf[i];')')
        if (buf[i] != expect) {
            printf("Error at %s line %d: expect buf[%d]=IFMT($1) but got IFMT($1)\n",
                   __func__,__LINE__,i,expect,buf[i]);
            nerrs++;
        }
    }
    /* test non-default fill value */
    err = ncmpi_inq_varid(ncid, "var2", &varid2); CHECK_ERR
    if (coll_io)
        err = GET_VAR($1,_all)(ncid, varid2, buf);
    else
        err = GET_VAR($1)(ncid, varid2, buf);
    CHECK_ERR
    for (i=0; i<LEN; i++) {
        $1 expect = fillv;
        ifelse(`$1',`schar',`ifelse(`$2',`uchar',`if (cdf != NC_FORMAT_CDF5) expect = ($1)wbuf[i];')')
        if (buf[i] != expect) {
            printf("Error at %s line %d: expect buf[%d]=IFMT($1) but got IFMT($1)\n",
                   __func__,__LINE__,i,expect,buf[i]);
            nerrs++;
        }
    }
    err = ncmpi_close(ncid); CHECK_ERR
    return nerrs;
}
')dnl

foreach(`itype',(uchar,short,ushort,int,uint,float,double,longlong,ulonglong),`TEST_ERANGE_PUT(schar, itype)')
foreach(`itype',(schar,short,ushort,int,uint,float,double,longlong,ulonglong),`TEST_ERANGE_PUT(uchar, itype)')
foreach(`itype',(ushort,int,uint,float,double,longlong,ulonglong),`TEST_ERANGE_PUT(short, itype)')
foreach(`itype',(short,int,uint,float,double,longlong,ulonglong),`TEST_ERANGE_PUT(ushort, itype)')
foreach(`itype',(uint,float,double,longlong,ulonglong),`TEST_ERANGE_PUT(int, itype)')
foreach(`itype',(int,float,double,longlong,ulonglong),`TEST_ERANGE_PUT(uint, itype)')
TEST_ERANGE_PUT(float, double)

define(`TEST_ERANGE_GET',dnl
`dnl
static
int test_erange_get_$1_$2(const char *out_path, int coll_io, MPI_Info info) {
    int i, err, nerrs=0, ncid, dimid, varid, cdf;
    $1 wbuf[LEN];
    MPI_Comm comm=MPI_COMM_WORLD;

    /* create a new file */
    err = ncmpi_create(comm, out_path, NC_CLOBBER, info, &ncid); CHECK_ERR
    err = ncmpi_def_dim(ncid, "X", LEN, &dimid); CHECK_ERR
    err = ncmpi_def_var(ncid, "var", NC_TYPE($1), 1, &dimid, &varid); CHECK_ERR
    err = ncmpi_enddef(ncid); CHECK_ERR

    if (!coll_io) {
        err = ncmpi_begin_indep_data(ncid);
        CHECK_ERR
    }

    err = ncmpi_inq_format(ncid, &cdf); CHECK_ERR

    /* write MAX values */
    for (i=0; i<LEN; i++)
        wbuf[i] = ($1) ifelse(index(`$1',`u'), 0,`XTYPE_MAX($1)',`ifelse(index(`$2',`u'), 0,`-1', `XTYPE_MAX($1)')');
    if (coll_io)
        err = PUT_VAR($1,_all)(ncid, varid, wbuf);
    else
        err = PUT_VAR($1)(ncid, varid, wbuf);
    CHECK_ERR

    /* file sync before reading */
    if (!coll_io) {
        err = ncmpi_sync(ncid);
        CHECK_ERR
    }
    MPI_Barrier(MPI_COMM_WORLD);

    err = ncmpi_inq_varid(ncid, "var", &varid); CHECK_ERR

    /* get data with ERANGE values */
    $2 rbuf[LEN];
    if (coll_io)
        err = GET_VAR($2,_all)(ncid, varid, rbuf);
    else
        err = GET_VAR($2)(ncid, varid, rbuf);
    ifelse(`$1',`schar',`ifelse(`$2',`uchar',`if (cdf == NC_FORMAT_CDF2) CHECK_ERR',`EXP_ERR(NC_ERANGE)')',`EXP_ERR(NC_ERANGE)')

    for (i=0; i<LEN; i++) {
        $2 expect = ($2)NC_FILL_VALUE($2);
        ifelse(`$1',`schar',`ifelse(`$2',`uchar',`if (cdf != NC_FORMAT_CDF5) expect = ($2)wbuf[i];')')
        if (rbuf[i] != expect) {
            printf("Error at %s line %d: expect rbuf[%d]=IFMT($2) but got IFMT($2)\n",
                   __func__,__LINE__,i,expect,rbuf[i]);
            nerrs++;
        }
    }
    err = ncmpi_close(ncid); CHECK_ERR
    return nerrs;
}
')dnl

foreach(`itype',(uchar,short,ushort,int,uint,float,double,longlong,ulonglong),`TEST_ERANGE_GET(itype,schar)')
foreach(`itype',(schar,short,ushort,int,uint,float,double,longlong,ulonglong),`TEST_ERANGE_GET(itype,uchar)')
foreach(`itype',(ushort,int,uint,float,double,longlong,ulonglong),`TEST_ERANGE_GET(itype,short)')
foreach(`itype',(short,int,uint,float,double,longlong,ulonglong),`TEST_ERANGE_GET(itype,ushort)')
foreach(`itype',(uint,float,double,longlong,ulonglong),`TEST_ERANGE_GET(itype,int)')
foreach(`itype',(int,float,double,longlong,ulonglong),`TEST_ERANGE_GET(itype,uint)')
TEST_ERANGE_GET(double, float)

static
int test_io(const char *out_path,
            const char *in_path, /* ignored */
            int         format,
            int         coll_io,
            MPI_Info    info)
{
    char hint[MPI_MAX_INFO_VAL];
    int err, nerrs=0, flag;

    MPI_Info_get(info, "nc_burst_buf", MPI_MAX_INFO_VAL-1, hint, &flag);
    if (flag && strcasecmp(hint, "enable") == 0)
        bb_enabled = 1;
    else
        bb_enabled = 0;

    /* Set file format */
    err = ncmpi_set_default_format(format, NULL);
    CHECK_ERR

    nerrs += test_default_fill_mode(out_path, format, coll_io, info);

    nerrs += test_user_fill_mode(out_path, format, coll_io, info);

    /* test put ERANGE values */
    foreach(`itype', (uchar,short,int,float,double), `
    _CAT(`nerrs += test_erange_put_schar_',itype)'`(out_path, coll_io, info);')

    foreach(`itype', (ushort,int,uint,float,double), `
    _CAT(`nerrs += test_erange_put_short_',itype)'`(out_path, coll_io, info);')

    foreach(`itype', (float,double), `
    _CAT(`nerrs += test_erange_put_int_',itype)'`(out_path, coll_io, info);')

    nerrs += test_erange_put_float_double(out_path, coll_io, info);

    /* test get ERANGE values */
    foreach(`itype', (short,int,float,double), `
    _CAT(`nerrs += test_erange_get_',itype)'`_schar(out_path, coll_io, info);')

    foreach(`itype', (schar,short,int,float,double), `
    _CAT(`nerrs += test_erange_get_',itype)'`_uchar(out_path, coll_io, info);')

    foreach(`itype', (int,float,double), `
    _CAT(`nerrs += test_erange_get_',itype)'`_short(out_path, coll_io, info);')

    foreach(`itype', (float,double), `
    _CAT(`nerrs += test_erange_get_',itype)'`_int(out_path, coll_io, info);')

    nerrs += test_erange_get_double_float(out_path, coll_io, info);

    /*---- CDF-5 format -----------------------------------------------------*/
    if (format == NC_FORMAT_CDF5) {

        /* test put ERANGE values */
        foreach(`itype', (ushort,uint,longlong,ulonglong), `
        _CAT(`nerrs += test_erange_put_schar_',itype)'`(out_path, coll_io, info);')

        foreach(`itype', (schar,short,ushort,int,uint,float,double,longlong,ulonglong), `
        _CAT(`nerrs += test_erange_put_uchar_',itype)'`(out_path, coll_io, info);')

        foreach(`itype', (longlong,ulonglong), `
        _CAT(`nerrs += test_erange_put_short_',itype)'`(out_path, coll_io, info);')

        foreach(`itype', (short,int,uint,float,double,longlong,ulonglong), `
        _CAT(`nerrs += test_erange_put_ushort_',itype)'`(out_path, coll_io, info);')

        foreach(`itype', (uint,longlong,ulonglong), `
        _CAT(`nerrs += test_erange_put_int_',itype)'`(out_path, coll_io, info);')

        foreach(`itype', (int,float,double,longlong,ulonglong), `
        _CAT(`nerrs += test_erange_put_uint_',itype)'`(out_path, coll_io, info);')

        nerrs += test_erange_put_float_double(out_path, coll_io, info);

        /* test get ERANGE values */
        foreach(`itype', (uchar,ushort,uint,longlong,ulonglong), `
        _CAT(`nerrs += test_erange_get_',itype)'`_schar(out_path, coll_io, info);')

        foreach(`itype', (ushort,uint,longlong,ulonglong), `
        _CAT(`nerrs += test_erange_get_',itype)'`_uchar(out_path, coll_io, info);')

        foreach(`itype', (ushort,uint,longlong,ulonglong), `
        _CAT(`nerrs += test_erange_get_',itype)'`_short(out_path, coll_io, info);')

        foreach(`itype', (short,int,uint,float,double,longlong,ulonglong), `
        _CAT(`nerrs += test_erange_get_',itype)'`_ushort(out_path, coll_io, info);')

        foreach(`itype', (uint,longlong,ulonglong), `
        _CAT(`nerrs += test_erange_get_',itype)'`_int(out_path, coll_io, info);')

        foreach(`itype', (int,float,double,longlong,ulonglong), `
        _CAT(`nerrs += test_erange_get_',itype)'`_uint(out_path, coll_io, info);')
    }

    return nerrs;
}

int main(int argc, char **argv) {

    int err;
    int formats[] = {NC_FORMAT_CLASSIC, NC_FORMAT_64BIT_OFFSET, NC_FORMAT_64BIT_DATA};
    loop_opts opt;

    MPI_Init(&argc, &argv);

    opt.num_fmts = sizeof(formats) / sizeof(int);
    opt.formats  = formats;
    opt.ina      = 1; /* test intra-node aggregation */
    opt.drv      = 1; /* test PNCIO driver */
    opt.ind      = 1; /* test hint romio_no_indep_rw */
    opt.chk      = 0; /* test hint pnc_data_move_chunk_size */
    opt.bb       = 1; /* test burst-buffering feature */
    opt.mod      = 1; /* test independent data mode */
    opt.hdr_diff = 1; /* run ncmpidiff for file header only */
    opt.var_diff = 1; /* run ncmpidiff for variables */

    err = tst_main(argc, argv, "erange elements are filled", opt, test_io);

    MPI_Finalize();

    return err;
}

dnl Process this m4 file to produce 'C' language file.
dnl
dnl If you see this line, you can ignore the next one.
/* Do not edit this file. It is produced from the corresponding .m4 source */
dnl
/*********************************************************************
 *
 *  Copyright (C) 2017, Northwestern University and Argonne National Laboratory
 *  See COPYRIGHT notice in top-level directory.
 *
 *********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h> /* strcpy(), strncpy() */
#include <libgen.h> /* basename() */
#include <mpi.h>
#include <pnetcdf.h>

#include <testutils.h>

#define NDIMS 3
#define LEN   13

static int debug;

include(`foreach.m4')dnl
include(`utils.m4')dnl

#define text char
#ifndef schar
#define schar signed char
#endif
#ifndef uchar
#define uchar unsigned char
#endif
#ifndef ushort
#define ushort unsigned short
#endif
#ifndef uint
#define uint unsigned int
#endif
#ifndef longlong
#define longlong long long
#endif
#ifndef ulonglong
#define ulonglong unsigned long long
#endif

#define INIT_BUF(buf, len) { \
    for (i=0; i<len; i++) \
        buf[i] = (rank + i + 1) % 128; \
}

#define ZERO_OUT_BUF(buf, len) { \
    for (i=0; i<len; i++) \
        buf[i] = 0; \
}

define(`MALLOC_ITYPE', `ifelse(`$1',`text',`char $2 = (char*) malloc(sizeof(char) * $3);',
                                             `$1 $2 = ($1*)   malloc(sizeof($1)   * $3);')')

define(`DEFINE_VARS',dnl
`dnl
static int
def_vars_$1(int  rank,
            int  ncid,
            int *dimids)
{
    int err=NC_NOERR;
    int var1_id, vara_id, vars_id, varm_id;
    int dimid, dimidsT[NDIMS];

    err = ncmpi_inq_dimid(ncid, "nprocs", &dimid); CHECK_ERR

    err = ncmpi_def_var(ncid, "var1_$1", NC_TYPE($1),     1, &dimid, &var1_id);
    CHECK_ERR
    err = ncmpi_def_var(ncid, "vara_$1", NC_TYPE($1), NDIMS, dimids, &vara_id);
    CHECK_ERR
    err = ncmpi_def_var(ncid, "vars_$1", NC_TYPE($1), NDIMS, dimids, &vars_id);
    CHECK_ERR

    err = ncmpi_def_var_fill(ncid, var1_id, 0, NULL); CHECK_ERR

    /* define variable with transposed file layout: ZYX -> YXZ */
    dimidsT[0] = dimids[1]; dimidsT[1] = dimids[2]; dimidsT[2] = dimids[0];
    err = ncmpi_def_var(ncid, "varm_$1", NC_TYPE($1), NDIMS, dimidsT, &varm_id);
    CHECK_ERR

    return err;
}
')dnl

foreach(`itype',(`text,schar,uchar,short,ushort,int,uint,long,float,double,longlong,ulonglong'),`DEFINE_VARS(itype)')

define(`TEST_NON_BLOCKING_PUT',dnl
`dnl
static int
non_blocking_put_$1(int         rank,
                    int         coll_io,
                    int         ncid,
                    MPI_Offset *gsize,
                    MPI_Offset *start,
                    MPI_Offset *count,
                    MPI_Offset *startS,
                    MPI_Offset *countS,
                    MPI_Offset *stride,
                    MPI_Offset *startM,
                    MPI_Offset *countM,
                    MPI_Offset *imap)
{
    int i, err=NC_NOERR, exp;
    int var1_id, vara_id, vars_id, varm_id;
    MPI_Offset start1[1];
    size_t bufsize, bufsizeS, bufsizeM;

    err = ncmpi_inq_varid(ncid, "var1_$1", &var1_id); CHECK_ERR
    err = ncmpi_inq_varid(ncid, "vara_$1", &vara_id); CHECK_ERR
    err = ncmpi_inq_varid(ncid, "vars_$1", &vars_id); CHECK_ERR
    err = ncmpi_inq_varid(ncid, "varm_$1", &varm_id); CHECK_ERR

    bufsize = bufsizeS = bufsizeM = 1;
    for (i=0; i<NDIMS; i++) {
        bufsize  *= count[i];
        bufsizeS *= countS[i];
        bufsizeM *= countM[i];
    }

    MALLOC_ITYPE($1, *buf1, 1)
    MALLOC_ITYPE($1, *bufa, bufsize)
    MALLOC_ITYPE($1, *bufs, bufsizeS)
    MALLOC_ITYPE($1, *bufm, bufsizeM)

    INIT_BUF(buf1, 1)
    INIT_BUF(bufa, bufsize)
    INIT_BUF(bufs, bufsizeS)
    INIT_BUF(bufm, bufsizeM)

    /* write the variable in parallel */
    start1[0] = rank;
    err = `ncmpi_iput_var1_'$1(ncid, var1_id, start1, buf1, NULL); CHECK_ERR

    err = `ncmpi_iput_vara_'$1(ncid, vara_id, start, count, bufa, NULL); CHECK_ERR

    err = `ncmpi_iput_vars_'$1(ncid, vars_id, startS, countS, stride, bufs, NULL); CHECK_ERR

    err = `ncmpi_iput_varm_'$1(ncid, varm_id, startM, countM, NULL, imap, bufm, NULL); CHECK_ERR

    /* commit all nonblocking requests */
    if (!coll_io)
        err = ncmpi_wait(ncid, NC_REQ_ALL, NULL, NULL);
    else
        err = ncmpi_wait_all(ncid, NC_REQ_ALL, NULL, NULL);
    CHECK_ERR

    /* Check write buffer contents, which should not be altered. */
    exp = (rank + 1) % 128;
    if (buf1[0] != exp) {
        printf("Error %s at %d: buf1 expects %.f but got %.f\n",
               __func__,__LINE__, (float)exp, (float)buf1[0]);
        CHECK_ERR
    }
    for (i=0; i<bufsizeM; i++) {
        exp = (rank + i + 1) % 128;
        if (bufa[i] != exp) {
            printf("Error %s at %d: bufa[%d] expects %.f but got %.f\n",
                   __func__,__LINE__, i, (float)exp, (float)bufa[i]);
            CHECK_ERR
        }
        if (bufs[i] != exp) {
            printf("Error %s at %d: bufs[%d] expects %.f but got %.f\n",
                   __func__,__LINE__, i, (float)exp, (float)bufs[i]);
            CHECK_ERR
        }
        if (bufm[i] != exp) {
            printf("Error %s at %d: buf[%d] expects %.f but got %.f\n",
                   __func__,__LINE__, i, (float)exp, (float)bufm[i]);
            CHECK_ERR
        }
    }

    free(buf1);
    free(bufa);
    free(bufs);
    free(bufm);

    return err;
}
')dnl

define(`TEST_NON_BLOCKING_GET',dnl
`dnl
static int
non_blocking_get_$1(int     rank,
                int         coll_io,
                int         ncid,
                MPI_Offset *start,
                MPI_Offset *count,
                MPI_Offset *startS,
                MPI_Offset *countS,
                MPI_Offset *stride,
                MPI_Offset *startM,
                MPI_Offset *countM,
                MPI_Offset *imap)
{
    int i, err, exp;
    int var1_id, vara_id, vars_id, varm_id;
    MPI_Offset start1[1];
    size_t bufsize, bufsizeS, bufsizeM;

    bufsize = bufsizeS = bufsizeM = 1;
    for (i=0; i<NDIMS; i++) {
        bufsize  *= count[i];
        bufsizeS *= countS[i];
        bufsizeM *= countM[i];
    }

    MALLOC_ITYPE($1, *buf1, 1)
    MALLOC_ITYPE($1, *bufa, bufsize)
    MALLOC_ITYPE($1, *bufs, bufsizeS)
    MALLOC_ITYPE($1, *bufm, bufsizeM)

    ZERO_OUT_BUF(buf1, 1)
    ZERO_OUT_BUF(bufa, bufsize)
    ZERO_OUT_BUF(bufs, bufsizeS)
    ZERO_OUT_BUF(bufm, bufsizeM)

    err = ncmpi_inq_varid(ncid, "var1_$1", &var1_id); CHECK_ERR
    err = ncmpi_inq_varid(ncid, "vara_$1", &vara_id); CHECK_ERR
    err = ncmpi_inq_varid(ncid, "vars_$1", &vars_id); CHECK_ERR
    err = ncmpi_inq_varid(ncid, "varm_$1", &varm_id); CHECK_ERR

    /* write the variable in parallel */
    start1[0] = rank;
    err = `ncmpi_iget_var1_'$1(ncid, var1_id, start1, buf1, NULL); CHECK_ERR

    err = `ncmpi_iget_vara_'$1(ncid, vara_id, start, count, bufa, NULL); CHECK_ERR

    err = `ncmpi_iget_vars_'$1(ncid, vars_id, startS, countS, stride, bufs, NULL); CHECK_ERR

    err = `ncmpi_iget_varm_'$1(ncid, varm_id, startM, countM, NULL, imap, bufm, NULL); CHECK_ERR

    /* commit all nonblocking requests */
    if (!coll_io)
        err = ncmpi_wait(ncid, NC_REQ_ALL, NULL, NULL);
    else
        err = ncmpi_wait_all(ncid, NC_REQ_ALL, NULL, NULL);
    CHECK_ERR

    /* Check read contents */
    exp = (rank + 1) % 128;
    if (buf1[0] != exp) {
        printf("Error %s at %d: buf1 expects %.f but got %.f\n",
               __func__,__LINE__, (float)exp, (float)buf1[0]);
        CHECK_ERR
    }
    for (i=0; i<bufsizeM; i++) {
        exp = (rank + i + 1) % 128;
        if (bufa[i] != exp) {
            printf("Error %s at %d: bufa[%d] expects %.f but got %.f\n",
                   __func__,__LINE__, i, (float)exp, (float)bufa[i]);
            CHECK_ERR
        }
        if (bufs[i] != exp) {
            printf("Error %s at %d: bufs[%d] expects %.f but got %.f\n",
                   __func__,__LINE__, i, (float)exp, (float)bufs[i]);
            CHECK_ERR
        }
        if (bufm[i] != exp) {
            printf("Error %s at %d: buf[%d] expects %.f but got %.f\n",
                   __func__,__LINE__, i, (float)exp, (float)bufm[i]);
            CHECK_ERR
        }
    }

    free(buf1);
    free(bufa);
    free(bufs);
    free(bufm);

    return err;
}
')dnl

foreach(`itype',(`text,schar,uchar,short,ushort,int,uint,long,float,double,longlong,ulonglong'),`TEST_NON_BLOCKING_PUT(itype)')
foreach(`itype',(`text,schar,uchar,short,ushort,int,uint,long,float,double,longlong,ulonglong'),`TEST_NON_BLOCKING_GET(itype)')

define(`TEST_CDF_FORMAT_PUT',dnl
`dnl
/* create a new $1 file */
    err = ncmpi_create(MPI_COMM_WORLD, out_path, NC_CLOBBER, info, &ncid);
    if (err != NC_NOERR) {
        printf("Error at line %d in %s: ncmpi_create() file %s (%s)\n",
        __LINE__,__FILE__,out_path,ncmpi_strerror(err));
        CHECK_ERR
    }

    /* define dimensions */
    _nprocs = ((nprocs + 3) / 4) * 4; /* round up 4 bytes */
    err = ncmpi_def_dim(ncid, "nprocs", _nprocs,  &dimids[0]); CHECK_ERR
    err = ncmpi_def_dim(ncid, "Z",      gsize[0], &dimids[0]); CHECK_ERR
    err = ncmpi_def_dim(ncid, "Y",      gsize[1], &dimids[1]); CHECK_ERR
    err = ncmpi_def_dim(ncid, "X",      gsize[2], &dimids[2]); CHECK_ERR

    /* define variables */
    err = def_vars_text(rank, ncid, dimids); CHECK_ERR
    foreach(`itype',(`schar, short, int, long, float, double'),`
    _CAT(`err = def_vars_',itype)'`(rank, ncid, dimids); CHECK_ERR')

    if (format == NC_FORMAT_64BIT_DATA) {
        foreach(`itype',(`uchar,ushort,uint,longlong,ulonglong'),`
        _CAT(`err = def_vars_',itype)'`(rank, ncid, dimids); CHECK_ERR')
    }

    err = ncmpi_enddef(ncid);

    if (!coll_io) {
        err = ncmpi_begin_indep_data(ncid);
        CHECK_ERR
    }

    err = non_blocking_put_text(rank, coll_io, ncid, gsize, start, count,
             startS, countS, stride, startM, countM, imap);
    CHECK_ERR
    foreach(`itype',(`schar, short, int, long, float, double'),`
    _CAT(`err = non_blocking_put_',itype)'`(rank, coll_io, ncid, gsize, start,
             count, startS, countS, stride, startM, countM, imap); CHECK_ERR')

    if (format == NC_FORMAT_64BIT_DATA) {
        foreach(`itype',(`uchar,ushort,uint,longlong,ulonglong'),`
        _CAT(`err = non_blocking_put_',itype)'`(rank, coll_io, ncid, gsize, start,
             count, startS, countS, stride, startM, countM, imap); CHECK_ERR')
    }

    if (!coll_io) {
        /* When in independent data mode, flushing writes is necessary before
         * reading the data back.
         */
        MPI_Barrier(MPI_COMM_WORLD);
        err = ncmpi_sync(ncid);
        CHECK_ERR
        MPI_Barrier(MPI_COMM_WORLD);
    }

    /* close the file */
    err = ncmpi_close(ncid);
    CHECK_ERR
')dnl

define(`TEST_CDF_FORMAT_GET',dnl
`dnl
/* open file */

    err = ncmpi_open(MPI_COMM_WORLD, out_path, NC_NOWRITE, info, &ncid);
    if (err != NC_NOERR) {
        printf("Error at line %d in %s: ncmpi_open() file %s (%s)\n",
        __LINE__,__FILE__,out_path,ncmpi_strerror(err));
        MPI_Abort(MPI_COMM_WORLD, -1);
        exit(1);
    }

    if (!coll_io) {
        err = ncmpi_begin_indep_data(ncid);
        CHECK_ERR
    }

    /* inquire dimensions */
    _nprocs = ((nprocs + 3) / 4) * 4; /* round up 4 bytes */
    err = ncmpi_inq_dimid(ncid, "nprocs", &dimids[0]); CHECK_ERR
    err = ncmpi_inq_dimid(ncid, "Z",      &dimids[0]); CHECK_ERR
    err = ncmpi_inq_dimid(ncid, "Y",      &dimids[1]); CHECK_ERR
    err = ncmpi_inq_dimid(ncid, "X",      &dimids[2]); CHECK_ERR

    err = non_blocking_get_text(rank, coll_io, ncid, start,
             count, startS, countS, stride, startM, countM, imap);
    CHECK_ERR
    foreach(`itype',(`schar, short, int, long, float, double'),`
    _CAT(`err = non_blocking_get_',itype)'`(rank, coll_io, ncid, start,
             count, startS, countS, stride, startM, countM, imap); CHECK_ERR')

    if (format == NC_FORMAT_64BIT_DATA) {
        foreach(`itype',(`uchar,ushort,uint,longlong,ulonglong'),`
        _CAT(`err = non_blocking_get_',itype)'`(rank, coll_io, ncid, start,
             count, startS, countS, stride, startM, countM, imap); CHECK_ERR')
    }

    /* close the file */
    err = ncmpi_close(ncid);
    CHECK_ERR
')dnl

static
int test_io(const char *out_path,
            const char *in_path, /* ignored */
            int         format,
            int         coll_io,
            MPI_Info    info)
{
    int i, rank, nprocs, ncid, err=NC_NOERR;
    int psize[NDIMS], dimids[NDIMS], dim_rank[NDIMS];
    MPI_Offset _nprocs;
    MPI_Offset gsize[NDIMS], stride[NDIMS], imap[NDIMS];
    MPI_Offset start[NDIMS], count[NDIMS];
    MPI_Offset startS[NDIMS], countS[NDIMS];
    MPI_Offset startM[NDIMS], countM[NDIMS];

    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &nprocs);

    /* calculate number of processes along each dimension */
    for (i=0; i<NDIMS; i++) psize[i] = 0;
    MPI_Dims_create(nprocs, NDIMS, psize);

    /* for each MPI rank, find its local rank IDs along each dimension in
     * dim_rank[] */
    int lower_dims=1;
    for (i=NDIMS-1; i>=0; i--) {
        dim_rank[i] = rank / lower_dims % psize[i];
        lower_dims *= psize[i];
    }

    /* calculate gsize[], global array sizes and set arguments start and count
     * for vara APIs */
    for (i=0; i<NDIMS; i++) {
        gsize[i]  = (MPI_Offset)LEN * psize[i];    /* global array size */
        start[i]  = (MPI_Offset)LEN * dim_rank[i]; /* start indices */
        count[i]  = (MPI_Offset)LEN;               /* array elements */
    }
    if (debug)
        printf("start=%lld %lld %lld count=%lld %lld %lld\n",
               start[0],start[1],start[2],count[0],count[1],count[2]);

    /* set arguments start, count, stride for vars APIs */
    for (i=0; i<NDIMS; i++) {
        startS[i] = dim_rank[i];
        countS[i] = gsize[i] / psize[i];
        stride[i] = psize[i];
    }
    if (debug)
        printf("startS=%lld %lld %lld countS=%lld %lld %lld stride=%lld %lld %lld\n",
               start[0],start[1],start[2],count[0],count[1],count[2],
               stride[0],stride[1],stride[2]);

    /* ZYX -> YXZ: (this is borrowed from examples/C/transpose.c */
    imap[1] = 1; imap[0] = count[2]; imap[2] = count[1]*count[2];
    startM[0] = start[1]; startM[1] = start[2]; startM[2] = start[0];
    countM[0] = count[1]; countM[1] = count[2]; countM[2] = count[0];
    if (debug)
        printf("startM=%lld %lld %lld countM=%lld %lld %lld stride=%lld %lld %lld imap=%lld %lld %lld\n",
               start[0],start[1],start[2],count[0],count[1],count[2],
               stride[0],stride[1],stride[2], imap[0],imap[1],imap[2]);

    MPI_Info_set(info, "nc_var_align_size", "1");

    /* Set format. */
    err = ncmpi_set_default_format(format, NULL);
    CHECK_ERR

    TEST_CDF_FORMAT_PUT
    TEST_CDF_FORMAT_GET

    return err;
}

int main(int argc, char **argv) {

    int err;
    int formats[] = {NC_FORMAT_CLASSIC, NC_FORMAT_64BIT_OFFSET, NC_FORMAT_64BIT_DATA};

    loop_opts opt;

    MPI_Init(&argc, &argv);

    opt.num_fmts = sizeof(formats) / sizeof(int);
    opt.formats  = formats;
    opt.ina      = 1; /* test intra-node aggregation */
    opt.drv      = 1; /* test PNCIO driver */
    opt.ind      = 1; /* test hint romio_no_indep_rw */
    opt.chk      = 0; /* test hint nc_data_move_chunk_size */
    opt.bb       = 1; /* test burst-buffering feature */
    opt.mod      = 1; /* test independent data mode */
    opt.hdr_diff = 1; /* run ncmpidiff for file header only */
    opt.var_diff = 1; /* run ncmpidiff for variables */

    err = tst_main(argc, argv, "all kinds iput APIs", opt, test_io);

    MPI_Finalize();

    return err;
}

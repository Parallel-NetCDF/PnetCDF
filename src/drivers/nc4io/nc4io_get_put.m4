dnl Process this m4 file to produce 'C' language file.
dnl
dnl If you see this line, you can ignore the next one.
/* Do not edit this file. It is produced from the corresponding .m4 source */
dnl
/*
 *  Copyright (C) 2018, Northwestern University and Argonne National Laboratory
 *  See COPYRIGHT notice in top-level directory.
 */
/* $Id$ */
dnl
include(`foreach.m4')dnl
include(`utils.m4')dnl
dnl
define(`upcase', `translit(`$*', `a-z', `A-Z')')dnl
dnl
define(`GETATTTYPE',dnl
`dnl
    ifelse($1, `MPI_CHAR', , `else ')if (itype == $1){
        err = ifelse($1, `MPI_DATATYPE_NULL', `nc_get_att', `nc_get_att_')$2(nc4p->ncid, varid, name, ($3*) buf);
    }
')dnl
dnl
define(`PUTATTTYPE',dnl
`dnl
    ifelse($1, `MPI_CHAR', , `else ')if (itype == $1){
        err = ifelse($1, `MPI_DATATYPE_NULL', `nc_put_att', `nc_put_att_')$2(nc4p->ncid, varid, name, ifelse($1, `MPI_CHAR', , `xtype, ')len, ($3*) value);
    }
')dnl
dnl
define(`GETVARTYPE',dnl
`dnl
        ifelse($2, `MPI_CHAR', , `else ')if (buftype == $2){
            err = nc_get_$1_$3(nc4p->ncid, varid, ifelse($1, `var1', `sstart, ', $1, `vara', `sstart, scount, ', $1, `vars', `sstart, scount, sstride, ', $1, `varm', `sstart, scount, sstride, simap, ')($4*) buf);
        }
')dnl
dnl
define(`PUTVARTYPE',dnl
`dnl
        ifelse($2, `MPI_CHAR', , `else ')if (buftype == $2){
            err = nc_put_$1_$3(nc4p->ncid, varid, ifelse($1, `var1', `sstart, ', $1, `vara', `sstart, scount, ', $1, `vars', `sstart, scount, sstride, ', $1, `varm', `sstart, scount, sstride, simap, ')($4*) buf);
        }
')dnl
dnl
define(`GETVAR',dnl
`dnl
    ifelse($1, `var', , `else ')if (apikind == NC4_API_KIND_$2){
foreach(`dt', (`(`MPI_CHAR', `text', `char')', dnl
               `(`MPI_SIGNED_CHAR', `schar', `signed char')', dnl
               `(`MPI_UNSIGNED_CHAR', `uchar', `unsigned char')', dnl
               `(`MPI_SHORT', `short', `short')', dnl
               `(`MPI_UNSIGNED_SHORT', `ushort', `unsigned short')', dnl
               `(`MPI_INT', `int', `int')', dnl
               `(`MPI_UNSIGNED', `uint', `unsigned int')', dnl
               `(`MPI_LONG', `long', `long')', dnl
               `(`MPI_FLOAT', `float', `float')', dnl
               `(`MPI_DOUBLE', `double', `double')', dnl
               `(`MPI_LONG_LONG_INT', `longlong', `long long')', dnl
               `(`MPI_UNSIGNED_LONG_LONG', `ulonglong', `unsigned long long')', dnl
               ), `GETVARTYPE($1, translit(dt, `()'))')dnl
    }
')dnl
dnl
define(`PUTVAR',dnl
`dnl
    ifelse($1, `var', , `else ')if (apikind == NC4_API_KIND_$2){
foreach(`dt', (`(`MPI_CHAR', `text', `char')', dnl
               `(`MPI_SIGNED_CHAR', `schar', `signed char')', dnl
               `(`MPI_UNSIGNED_CHAR', `uchar', `unsigned char')', dnl
               `(`MPI_SHORT', `short', `short')', dnl
               `(`MPI_UNSIGNED_SHORT', `ushort', `unsigned short')', dnl
               `(`MPI_INT', `int', `int')', dnl
               `(`MPI_UNSIGNED', `uint', `unsigned int')', dnl
               `(`MPI_LONG', `long', `long')', dnl
               `(`MPI_FLOAT', `float', `float')', dnl
               `(`MPI_DOUBLE', `double', `double')', dnl
               `(`MPI_LONG_LONG_INT', `longlong', `long long')', dnl
               `(`MPI_UNSIGNED_LONG_LONG', `ulonglong', `unsigned long long')', dnl
               ), `PUTVARTYPE($1, translit(dt, `()'))')dnl
    }
')dnl
dnl
define(`CONVERT',dnl
`dnl
        if ($1 != NULL){
            /* Allocate s$1 */
            s$1 = ($2*)NCI_Malloc(sizeof($2) * ndim);
            if (s$1 == NULL){
                DEBUG_RETURN_ERROR(NC_ENOMEM)
            }

            /* Convert to size_t */
            for (i=0; i<ndim; i++) {
                s$1[i] = ($2) $1[i];
            }
        }
')dnl
dnl
define(`FREE',dnl
`dnl
        if ($1 != NULL){
            /* Free s$1 */
            NCI_Free(s$1);
        }
')dnl
dnl

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

/* Note, netcdf header must come first due to conflicting constant definition */
#include <netcdf.h>

#include <stdio.h>
#include <stdlib.h>

#include <mpi.h>
#include <pnc_debug.h>
#include <common.h>
#include <nc4io_driver.h>

int
nc4io_get_att(void         *ncdp,
              int           varid,
              const char   *name,
              void         *buf,
              MPI_Datatype  itype)
{
    int err;
    NC_nc4 *nc4p = (NC_nc4*)ncdp;

    /* Call nc_del_att_<type> */
foreach(`dt', (`(`MPI_CHAR', `text', `char')', dnl
               `(`MPI_SIGNED_CHAR', `schar', `signed char')', dnl
               `(`MPI_UNSIGNED_CHAR', `uchar', `unsigned char')', dnl
               `(`MPI_SHORT', `short', `short')', dnl
               `(`MPI_UNSIGNED_SHORT', `ushort', `unsigned short')', dnl
               `(`MPI_INT', `int', `int')', dnl
               `(`MPI_UNSIGNED', `uint', `unsigned int')', dnl
               `(`MPI_FLOAT', `float', `float')', dnl
               `(`MPI_DOUBLE', `double', `double')', dnl
               `(`MPI_LONG_LONG_INT', `longlong', `long long')', dnl
               `(`MPI_UNSIGNED_LONG_LONG', `ulonglong', `unsigned long long')', dnl
               `(`MPI_DATATYPE_NULL', `', `void')', dnl
               ), `GETATTTYPE(translit(dt, `()'))')dnl
    if (err != NC_NOERR) DEBUG_RETURN_ERROR(err);

    return NC_NOERR;
}

int
nc4io_put_att(void         *ncdp,
              int           varid,
              const char   *name,
              nc_type       xtype,
              MPI_Offset    nelems,
              const void    *value,
              MPI_Datatype  itype)
{
    int err;
    size_t len;
    NC_nc4 *nc4p = (NC_nc4*)ncdp;

    /* Convert from MPI_Offset to size_t */
    len = (size_t)nelems;

    /* Call nc_del_att_<type> */
foreach(`dt', (`(`MPI_CHAR', `text', `char')', dnl
               `(`MPI_SIGNED_CHAR', `schar', `signed char')', dnl
               `(`MPI_UNSIGNED_CHAR', `uchar', `unsigned char')', dnl
               `(`MPI_SHORT', `short', `short')', dnl
               `(`MPI_UNSIGNED_SHORT', `ushort', `unsigned short')', dnl
               `(`MPI_INT', `int', `int')', dnl
               `(`MPI_UNSIGNED', `uint', `unsigned int')', dnl
               `(`MPI_FLOAT', `float', `float')', dnl
               `(`MPI_DOUBLE', `double', `double')', dnl
               `(`MPI_LONG_LONG_INT', `longlong', `long long')', dnl
               `(`MPI_UNSIGNED_LONG_LONG', `ulonglong', `unsigned long long')', dnl
               `(`MPI_DATATYPE_NULL', `', `void')', dnl
               ), `PUTATTTYPE(translit(dt, `()'))')dnl
    if (err != NC_NOERR) DEBUG_RETURN_ERROR(err);

    return NC_NOERR;
}

int
nc4io_get_var(void             *ncdp,
              int               varid,
              const MPI_Offset *start,
              const MPI_Offset *count,
              const MPI_Offset *stride,
              const MPI_Offset *imap,
              void             *buf,
              MPI_Offset        bufcount,
              MPI_Datatype      buftype,
              int               reqMode)
{
    int i, err;
    int apikind;
    int ndim;
    size_t *sstart, *scount;
    ptrdiff_t *sstride, *simap;
    NC_nc4 *nc4p = (NC_nc4*)ncdp;

    /* Inq variable dim */
    err = nc_inq_varndims(nc4p->ncid, varid, &ndim);
    if (err != NC_NOERR) DEBUG_RETURN_ERROR(err);

    if (start == NULL){
        apikind = NC4_API_KIND_VAR;
        // VAR should be transformed to VARA by the dispatcher
        if (ndim > 0){
            DEBUG_RETURN_ERROR(NC_EINVAL);
        }
    }
    else if (count == NULL){
        apikind = NC4_API_KIND_VAR1;
        // VAR1 should be transformed to VARA by the dispatcher
        if (ndim > 0){
            DEBUG_RETURN_ERROR(NC_EINVAL);
        }
    }
    else if (stride == NULL){
        apikind = NC4_API_KIND_VARA;
    }
    else if (imap == NULL){
        apikind = NC4_API_KIND_VARS;
    }
    else{
        apikind = NC4_API_KIND_VARM;
    }

    /* Convert to MPI_Offset if not scalar */
    if(ndim > 0){
foreach(`arg', `(start, count)', `CONVERT(arg, size_t)') dnl
foreach(`arg', `(stride, imap)', `CONVERT(arg, ptrdiff_t)') dnl
    }
    else{
        sstart = scount = NULL;
        sstride = simap = NULL;
    }

foreach(`api', `(var, var1, vara, vars, varm)', `GETVAR(api, upcase(api))') dnl
    if (err != NC_NOERR){
        DEBUG_RETURN_ERROR(err);
    }

    /* Free buffers if needed */
    if(ndim > 0){
foreach(`arg', `(start, count, stride, imap)', `FREE(arg)') dnl
    }

    return NC_NOERR;
}

int
nc4io_put_var(void             *ncdp,
              int               varid,
              const MPI_Offset *start,
              const MPI_Offset *count,
              const MPI_Offset *stride,
              const MPI_Offset *imap,
              const void       *buf,
              MPI_Offset        bufcount,
              MPI_Datatype      buftype,
              int               reqMode)
{
    int i, err;
    int apikind;
    int ndim;
    int zero_req = 0;
    size_t *sstart, *scount, putsize;
    ptrdiff_t *sstride, *simap;
    NC_nc4 *nc4p = (NC_nc4*)ncdp;

    /* Inq variable dim */
    err = nc_inq_varndims(nc4p->ncid, varid, &ndim);
    if (err != NC_NOERR) DEBUG_RETURN_ERROR(err);

    if (start == NULL){
        apikind = NC4_API_KIND_VAR;
        // VAR should be transformed to VARA by the dispatcher
        if (ndim > 0){
            DEBUG_RETURN_ERROR(NC_EINVAL);
        }
    }
    else if (count == NULL){
        apikind = NC4_API_KIND_VAR1;
        // VAR1 should be transformed to VARA by the dispatcher
        if (ndim > 0){
            DEBUG_RETURN_ERROR(NC_EINVAL);
        }
    }
    else{
        if (stride == NULL){
            apikind = NC4_API_KIND_VARA;
        }
        else if (imap == NULL){
            apikind = NC4_API_KIND_VARS;
        }
        else{
            apikind = NC4_API_KIND_VARM;
        }

        // NetCDF/HDF5 does not allow 0 put size, skip it here */
        if (ndim > 0){
            putsize = (size_t)count[0];
            for(i = 1; i < ndim; i++){
                putsize *= (size_t)count[i];
            }
            if (putsize <= 0){
                /* Zero req will cause error in hdf5 layer under some unknown conditions
                 * We simply ignore the error code if request size is 0
                 */
                zero_req = 1;
            }
        }
    }

    /* Convert to MPI_Offset if not scalar */
    if(ndim > 0){
foreach(`arg', `(start, count)', `CONVERT(arg, size_t)') dnl
foreach(`arg', `(stride, imap)', `CONVERT(arg, ptrdiff_t)') dnl
    }
    else{
        sstart = scount = NULL;
        sstride = simap = NULL;
    }

foreach(`api', `(var, var1, vara, vars, varm)', `PUTVAR(api, upcase(api))') dnl
    /* Zero req will cause error in hdf5 layer under some unknown conditions
     * We simply ignore the error code if request size is 0
     */
    if (zero_req && err == NC_EHDFERR){
        err = NC_NOERR;
    }
    if (err != NC_NOERR){
        DEBUG_RETURN_ERROR(err);
    }

    /* Free buffers if needed */
    if(ndim > 0){
foreach(`arg', `(start, count, stride, imap)', `FREE(arg)') dnl
    }

    return NC_NOERR;
}

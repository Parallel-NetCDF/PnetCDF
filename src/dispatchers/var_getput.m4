dnl Process this m4 file to produce 'C' language file.
dnl
dnl If you see this line, you can ignore the next one.
/* Do not edit this file. It is produced from the corresponding .m4 source */
dnl
/*
 *  Copyright (C) 2017, Northwestern University and Argonne National Laboratory
 *  See COPYRIGHT notice in top-level directory.
 */
/* $Id$ */

#if HAVE_CONFIG_H
# include <ncconfig.h>
#endif

#include <stdlib.h>

#include <dispatch.h>
#include <pnetcdf.h>
#include <nctypes.h>

dnl APINAME(/i/b,m, get/put, /1/a/s/m/n, itype, /_all)
define(`APINAME',`ifelse(`$4',`',`ncmpi_$1$2_var$3$5',dnl Flexible APIs
                                 `ncmpi_$1$2_var$3_$4$5')')dnl High-level APIs

include(`foreach.m4')dnl
include(`utils.m4')dnl

dnl
define(`APINAME',`ifelse(`$3',`',`ncmpi_$1_var$2$4',`ncmpi_$1_var$2_$3$4')')dnl
dnl
dnl GETPUT_API(get/put, /1/a/s/m, itype, /_all)
dnl
define(`GETPUT_API',dnl
`dnl
/*----< APINAME($1,$2,$3,$4)() >---------------------------------------------*/
int
APINAME($1,$2,$3,$4)(int ncid,
                     int varid,
                     ArgKind($2)
                     BufArgs($1,$3))
{
    int err;
    PNC *pncp;

    /* use NC_NAT to represent this is a flexible API */
ifelse(`$3',`',`    nc_type itype=NC_NAT;',
`$3',`long',`#if SIZEOF_LONG == SIZEOF_INT
    nc_type itype=NC_INT;
#elif SIZEOF_LONG == SIZEOF_LONG_LONG
    nc_type itype=NC_INT64;
#endif',`    nc_type itype=NC_TYPE($3);')

    /* check if ncid is valid.
     * For invalid ncid, we must return error now, as there is no way to
     * continue with invalid ncp. However, collective APIs might hang if this
     * error occurs only on a subset of processes
     */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements APINAME($1,$2,$3,$4)() */
    err = pncp->dispatch->`$1'_var(pncp->ncp, varid, ArgStartCountStrideMap($2),
                                   buf, ifelse(`$3', `', `bufcount, buftype',
                                                         `-1, ITYPE2MPI($3)'),
                                   API_KIND($2), itype, CollIndep($4));

    if (err != NC_NOERR) return err;

    return NC_NOERR;
}
')dnl
dnl
/*---- PnetCDF flexible APIs ------------------------------------------------*/
foreach(`kind', (, 1, a, s, m),
        `foreach(`putget', (put, get),
                 `foreach(`collindep', (, _all),
                          `GETPUT_API(putget,kind,,collindep)'
)')')

/*---- PnetCDF high-level APIs ----------------------------------------------*/
foreach(`kind', (, 1, a, s, m),
        `foreach(`putget', (put, get),
                 `foreach(`collindep', (, _all),
                          `foreach(`iType', (ITYPE_LIST),
                                   `GETPUT_API(putget,kind,iType,collindep)'
)')')')

/* ncmpi_get/put_varn_<type>_<mode> API:
 *    type:   data type of I/O buffer, buf
 *    mode:   independent (<nond>) or collective (_all)
 *
 * arguments:
 *    num:    number of start and count pairs
 *    starts: an 2D array of size [num][ndims]. Each starts[i][*] indicates
 *            the starting array indices for a subarray request. ndims is
 *            the number of dimensions of the defined netCDF variable.
 *    counts: an 2D array of size [num][ndims]. Each counts[i][*] indicates
 *            the number of array elements to be accessed. This argument
 *            can be NULL, equivalent to counts with all 1s.
 *    bufcount and buftype: these 2 arguments are only available for flexible
 *            APIs, indicating the I/O buffer memory layout. When buftype is
 *            MPI_DATATYPE_NULL, bufcount is ignored and the data type of buf
 *            is considered matched the variable data type defined in the file.
 */
dnl
define(`NAPINAME',`ifelse(`$3',`',`ncmpi_$1_varn$2',`ncmpi_$1_varn_$3$2')')dnl
dnl
dnl VARN(get/put, iType, /_all)
dnl
define(`VARN',dnl
`dnl
/*----< NAPINAME($1,$2,$3)() >-----------------------------------------------*/
int
NAPINAME($1,$2,$3)(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const *starts,
                   MPI_Offset* const *counts,
                   BufArgs($1,$3))
{
    int err;
    PNC *pncp;

    /* use NC_NAT to represent this is a flexible API */
ifelse(`$3',`',`    nc_type itype=NC_NAT;',
`$3',`long',`#if SIZEOF_LONG == SIZEOF_INT
    nc_type itype=NC_INT;
#elif SIZEOF_LONG == SIZEOF_LONG_LONG
    nc_type itype=NC_INT64;
#endif',`    nc_type itype=NC_TYPE($3);')

    /* check if ncid is valid.
     * For invalid ncid, we must return error now, as there is no way to
     * continue with invalid ncp. However, collective APIs might hang if this
     * error occurs only on a subset of processes
     */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements NAPINAME($1,$2,$3)() */
    err = pncp->dispatch->`$1'_varn(pncp->ncp, varid, num, starts, counts,
                                    buf, ifelse(`$3', `', `bufcount, buftype',
                                                          `-1, ITYPE2MPI($3)'),
                                    itype, CollIndep($2));

    if (err != NC_NOERR) return err;

    return NC_NOERR;
}
')dnl
dnl
/*---- PnetCDF flexible APIs ------------------------------------------------*/
foreach(`putget', (put, get),
        `foreach(`collindep', (, _all),
                 `VARN(putget,collindep)'
)')

/*---- PnetCDF high-level APIs ----------------------------------------------*/
foreach(`putget', (put, get),
        `foreach(`collindep', (, _all),
                 `foreach(`iType', (ITYPE_LIST),
                          `VARN(putget,collindep,iType)'
)')')

dnl
define(`MAPINAME',`ifelse(`$3',`',`ncmpi_m$1_var$2$4',`ncmpi_m$1_var$2_$3$4')')dnl
dnl
define(`MArgStartCountStrideMap', `ifelse(
       `$1', `',  `NULL,      NULL,      NULL,       NULL',
       `$1', `1', `starts[i], NULL,      NULL,       NULL',
       `$1', `a', `starts[i], counts[i], NULL,       NULL',
       `$1', `s', `starts[i], counts[i], strides[i], NULL',
       `$1', `m', `starts[i], counts[i], strides[i], imaps[i]')')dnl
dnl
dnl MVAR(put/get, /1/a/s/m, iType, /_all)
dnl
define(`MVAR',dnl
`dnl
/*----< MAPINAME($1,$2,$3,$4)() >--------------------------------------------*/
int
MAPINAME($1,$2,$3,$4)(int                ncid,
                      int                nvars,
                      int               *varids,
                      ifelse(`$2', `1', `MPI_Offset* const *starts,',
                             `$2', `a', `MPI_Offset* const *starts,
                                         MPI_Offset* const *counts,',
                             `$2', `s', `MPI_Offset* const *starts,
                                         MPI_Offset* const *counts,
                                         MPI_Offset* const *strides,',
                             `$2', `m', `MPI_Offset* const *starts,
                                         MPI_Offset* const *counts,
                                         MPI_Offset* const *strides,
                                         MPI_Offset* const *imaps,')
                      ifelse(`$3', `',
                         `ifelse($1,`get',`void **bufs,',`void* const *bufs,')
                         const MPI_Offset *bufcounts,
                         const MPI_Datatype *buftypes',
                         `ifelse($1,`get',`FUNC2ITYPE($3) **bufs',
                                          `FUNC2ITYPE($3)* const *bufs')'))
{
    int i, status=NC_NOERR, err, *reqs;
    PNC *pncp;

    /* use NC_NAT to represent this is a flexible API */
ifelse(`$3',`',`    nc_type itype=NC_NAT;',
`$3',`long',`#if SIZEOF_LONG == SIZEOF_INT
    nc_type itype=NC_INT;
#elif SIZEOF_LONG == SIZEOF_LONG_LONG
    nc_type itype=NC_INT64;
#endif',`    nc_type itype=NC_TYPE($3);')

    /* check if ncid is valid.
     * For invalid ncid, we must return error now, as there is no way to
     * continue with invalid ncp. However, collective APIs might hang if this
     * error occurs only on a subset of processes
     */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    reqs = (int*) malloc(nvars * sizeof(int));
    for (i=0; i<nvars; i++) {
        /* call the nonblocking subroutines */
        err = pncp->dispatch->i`$1'_var(pncp->ncp, varids[i],
                                        MArgStartCountStrideMap($2),
                                        bufs[i],
                                        ifelse(`$3',`',`bufcounts[i], buftypes[i]',
                                                       `-1, ITYPE2MPI($3)'),
                                        &reqs[i], API_KIND($2), itype);
        if (status != NC_NOERR) status = err;
    }

    err = pncp->dispatch->wait(pncp->ncp, nvars, reqs, NULL, CollIndep($4));
    if (status != NC_NOERR) status = err;
    free(reqs);

    return status;
}
')dnl
dnl
/*---- PnetCDF flexible APIs ------------------------------------------------*/
foreach(`kind', (, 1, a, s, m),
        `foreach(`putget', (put, get),
                 `foreach(`collindep', (, _all),
                          `MVAR(putget,kind,,collindep)'
)')')

/*---- PnetCDF high-level APIs ----------------------------------------------*/
foreach(`kind', (, 1, a, s, m),
        `foreach(`putget', (put, get),
                 `foreach(`collindep', (, _all),
                          `foreach(`iType', (ITYPE_LIST),
                                   `MVAR(putget,kind,iType,collindep)'
)')')')

dnl
define(`IAPINAME',`ifelse(`$3',`',`ncmpi_$1_var$2',`ncmpi_$1_var$2_$3')')dnl
dnl
dnl IGETPUT_API(iget/iput/bput, /1/a/s/m, itype)
dnl
define(`IGETPUT_API',dnl
`dnl
/*----< IAPINAME($1,$2,$3)() >-----------------------------------------------*/
int
IAPINAME($1,$2,$3)(int ncid,
                   int varid,
                   ArgKind($2)
                   BufArgs(substr($1,1),$3),
                   int *reqid)
{   
    int err;
    PNC *pncp;

    /* use NC_NAT to represent this is a flexible API */
ifelse(`$3',`',`    nc_type itype=NC_NAT;',
`$3',`long',`#if SIZEOF_LONG == SIZEOF_INT
    nc_type itype=NC_INT;
#elif SIZEOF_LONG == SIZEOF_LONG_LONG
    nc_type itype=NC_INT64;
#endif',`    nc_type itype=NC_TYPE($3);')

    /* check if ncid is valid.
     * For invalid ncid, we must return error now, as there is no way to
     * continue with invalid ncp. However, collective APIs might hang if this
     * error occurs only on a subset of processes
     */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements IAPINAME($1,$2,$3)() */
    err = pncp->dispatch->`$1'_var(pncp->ncp, varid, ArgStartCountStrideMap($2),
                                   buf, ifelse(`$3', `', `bufcount, buftype',
                                                         `-1, ITYPE2MPI($3)'),
                                   reqid, API_KIND($2), itype);

    if (err != NC_NOERR) return err;

    return NC_NOERR;
}
')dnl
dnl
/*---- PnetCDF flexible APIs ------------------------------------------------*/
foreach(`kind', (, 1, a, s, m),
        `foreach(`putget', (iput, iget, bput),
                 `IGETPUT_API(putget,kind,)'
)')

/*---- PnetCDF high-level APIs ----------------------------------------------*/
foreach(`kind', (, 1, a, s, m),
        `foreach(`putget', (iput, iget, bput),
                 `foreach(`iType', (ITYPE_LIST),
                          `IGETPUT_API(putget,kind,iType)'
)')')


/* ncmpi_iget/iput_varn_<type>_<mode> API:
 *    type:   data type of I/O buffer, buf
 *    mode:   indpendent (<nond>) or collective (_all)
 *
 * arguments:
 *    num:    number of start and count pairs
 *    starts: an 2D array of size [num][ndims]. Each starts[i][*] indicates
 *            the starting array indices for a subarray request. ndims is
 *            the number of dimensions of the defined netCDF variable.
 *    counts: an 2D array of size [num][ndims]. Each counts[i][*] indicates
 *            the number of array elements to be accessed. This argument
 *            can be NULL, equivalent to counts with all 1s.
 *    bufcount and buftype: these 2 arguments are only available for flexible
 *            APIs, indicating the I/O buffer memory layout. When buftype is
 *            MPI_DATATYPE_NULL, bufcount is ignored and the data type of buf
 *            is considered matched the variable data type defined in the file.
 *    reqid:  request ID returned to user
 */
dnl
define(`INAPINAME',`ifelse(`$2',`',`ncmpi_$1_varn',`ncmpi_$1_varn_$2')')dnl
dnl
dnl IVARN(iget/iput/bput, iType)
dnl
define(`IVARN',dnl
`dnl
/*----< ncmpi_$1_var$2() >---------------------------------------------------*/
int
INAPINAME($1,$2)(int                ncid,
                 int                varid,
                 int                num,
                 MPI_Offset* const *starts,
                 MPI_Offset* const *counts,
                 BufArgs(substr($1,1),$2),
                 int               *reqid)
{
    int err;
    PNC *pncp;

    /* use NC_NAT to represent this is a flexible API */
ifelse(`$2',`',`    nc_type itype=NC_NAT;',
`$2',`long',`#if SIZEOF_LONG == SIZEOF_INT
    nc_type itype=NC_INT;
#elif SIZEOF_LONG == SIZEOF_LONG_LONG
    nc_type itype=NC_INT64;
#endif',`    nc_type itype=NC_TYPE($2);')

    /* check if ncid is valid.
     * For invalid ncid, we must return error now, as there is no way to
     * continue with invalid ncp. However, collective APIs might hang if this
     * error occurs only on a subset of processes
     */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements INAPINAME($1,$2)() */
    err = pncp->dispatch->`$1'_varn(pncp->ncp, varid, num, starts, counts,
                                    buf, ifelse(`$2', `', `bufcount, buftype',
                                                          `-1, ITYPE2MPI($2)'),
                                    reqid, itype);

    if (err != NC_NOERR) return err;

    return NC_NOERR;
}
')dnl
dnl
/*---- PnetCDF flexible APIs ------------------------------------------------*/
foreach(`putget', (iget, iput, bput), `IVARN(putget)')

/*---- PnetCDF high-level APIs ----------------------------------------------*/
foreach(`putget', (iget, iput, bput),
        `foreach(`iType', (ITYPE_LIST),
                 `IVARN(putget,iType)'
)')

dnl
dnl VARD(get/put, /_all)
dnl
define(`VARD',dnl
`dnl
/*----< ncmpi_$1_vard$2() >--------------------------------------------------*/
int
ncmpi_$1_vard$2(int           ncid,
                int           varid,
                MPI_Datatype  filetype,  /* access layout to the variable in file
 */
                ifelse($1, `get', `void *buf', `const void *buf'),
                MPI_Offset    bufcount,
                MPI_Datatype  buftype)   /* data type of the buffer */
{
    int err;
    PNC *pncp;

    /* check if ncid is valid.
     * For invalid ncid, we must return error now, as there is no way to
     * continue with invalid ncp. However, collective APIs might hang if this
     * error occurs only on a subset of processes
     */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_$1_vard$2() */
    err = pncp->dispatch->$1_vard(pncp->ncp, varid, filetype, buf, bufcount,
                                  buftype, CollIndep($2));

    if (err != NC_NOERR) return err;

    return NC_NOERR;
}
')
dnl
foreach(`putget', (put, get),
        `foreach(`collindep', (, _all),
                 `VARD(putget,collindep)'
)')

dnl
dnl WAIT(collindep)
dnl
define(`WAIT',dnl
`dnl
/*----< ncmpi_wait$1() >-----------------------------------------------------*/
int
ncmpi_wait$1(int  ncid,
             int  num_reqs, /* number of requests */
             int *req_ids,  /* [num_reqs]: IN/OUT */
             int *statuses) /* [num_reqs], can be NULL */
{
    int err;
    PNC *pncp;

    /* check if ncid is valid.
     * For invalid ncid, we must return error now, as there is no way to
     * continue with invalid ncp. However, collective APIs might hang if this
     * error occurs only on a subset of processes
     */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_wait$1() */
    err = pncp->dispatch->wait(pncp->ncp, num_reqs, req_ids, statuses,
                               CollIndep($1));

    if (err != NC_NOERR) return err;

    return NC_NOERR;
}
')
WAIT()
WAIT(_all)

